# 结合Objective-C和Rust两种语言 深入理解栈(Stack)和堆(Heap)

### 堆和栈的一些区别

|                  |                 堆                 |               栈                |
| :--------------- | :--------------------------------: | :-----------------------------: |
| **管理方式**     |         程序员手动分配释放         |      操作系统自动分配释放       |
| **空间大小**     |                 大                 |               小                |
| **缓存方式**     |              二级缓存              |            一级缓存             |
| **能否产生碎片** |                 能                 |               否                |
| **生长方向**     |          向上地址内存增加          |        向上地址内存增加         |
| **空间分配方式** |                动态                |            静态+动态            |
| **分配效率**     |                 低                 |               高                |
| **数据结构**     | 类似于链表FIFO(first in first out) | 先进后出FILO(first in last out) |



> 个人理解：固定不可变的(比如静态变量)是存放在`Stack`中的，可变的变量是存在`heap`中的



### 下面看看在rust中 关于Stack和Heap系统是怎么玩的

``` rust
fn main () {
  let x = "lisa"; // x 分配在栈中 "lisa" 是个不可变的固定字符串
}
```

```rust
fn main() {
    //在 Rust 中，你可以使用Box<T>类型在堆上分配内存
    let x = Box::new(5);//x分配在栈上，值5分配在堆上，其地址存在x的栈中；
    //当函数结束，x消失时，它首先释放了分配在堆上的内存，也就是值5所在的堆空间被释放，接着自己所在的栈空间释放
}

```



Box 是堆上分配的内存，通过 `Box::new()` 会创建一个堆空间并返回一个指向堆空间的指针



下面看一个例子，对比一下 `Vec` 和 `Vec>` 内存布局，这两个图来自 [Stack Overflow](https://stackoverflow.com/questions/21066133/what-is-the-difference-between-veci32-and-vecboxi32/21067103#21067103)，从这两张内存分布图可以清楚直观地看出 Box 是如何存储的

```
Vec<i32>

(stack)    (heap)
┌──────┐   ┌───┐
│ vec1 │──→│ 1 │
└──────┘   ├───┤
           │ 2 │
           ├───┤
           │ 3 │
           ├───┤
           │ 4 │
           └───┘
```



```
Vec<Box<i32>>

(stack)    (heap)   ┌───┐
┌──────┐   ┌───┐ ┌─→│ 1 │
│ vec2 │──→│   │─┘  └───┘
└──────┘   ├───┤    ┌───┐
           │   │───→│ 2 │
           ├───┤    └───┘
           │   │─┐  ┌───┐
           ├───┤ └─→│ 3 │
           │   │─┐  └───┘
           └───┘ │  ┌───┐
                 └─→│ 4 │
                    └───┘
```



一般而言大小在编译时不能确定的数据类型都需要使用堆上内存，因为编译器无法为其在栈上分配固定大小的内存空间，例如 String, Vec，另外需要从函数中返回一个浅拷贝的变量时也需要使用堆内存而不能直接返回一个指向函数内部定义变量的引用。



+ http://hardocs.com/d/rustprimer/heap-stack/heap-stack.html

